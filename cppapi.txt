Clarity's C++ API involves several type and function mangling rules to handle cases where .NET's rules for type conversion don't have direct analogs in C++, especially related to generic expansion and vtable slotting.

Array covariance:
Array references are a pair corresponding to a type and a storage converter.  Todo...

Storing a reference into a reference array converts the passed type into the apparent type and then checks and converts it based on the array's backing store.  Rules are as follows:
- Interface assigned to class backing store: Resolves root RefTarget
- Interface assigned to interface backing store: If interface type is different, dynamically remapped
- object assigned to interface backing store: Dynamically remapped
- Class assigned to class backing store: Stored directly


Interface implementation:
There is only ever one copy of an interface implemented per object.  Interfaces with passive conversions to other interfaces expose passive conversion methods that the actual class implements.


Generic interface disambiguation:
It's possible for 2 generic interfaces to implement 2 methods that otherwise have the same signature.  For example:
public interface IMyInterface<T>
{
    void DoSomething();
}
public class MyClass : IMyInterface<int>, IMyInterface<bool>
{
    void IMyInterface<int>.DoSomething()
	{
	}

	void IMyInterface<bool>.DoSomething()
	{
	}
}

Because of this, virtual slots in generic interfaces are split into two functions: The normal "vs" slot for the call site and the "ivs" slot for the implementation binding.



Struct interface implementation:
Struct interfaces are implemented on the boxed class and static versions of the relevant methods are implemented on the base class.

There is a separate constrained call glue that is emitted for resolving constrained calls.


Static initialization:
Methods are generally split into "mcall" and "mcode" methods.  "mcall" performs static initialization, if necessary, and then enters mcode.

Primitive types:
All primitive types use the internal value types, which simplifies calling their methods.

Delegate covariance and contravariance:
Function pointers are "floated" as bind sites on the IL stack and then emitted as delegate bindings using templates when the delegate is created.


Constrained virtual calls:
Example:

T t;
t.DoSomething(1);

This is emitted as:
::CLRUtil::Val<T>::Type type;
::CLRUtil::Val<T>::Type* mptr = &type;
::CLRUtil::ConstrainedResolve<T, InterfaceType>(mptr)->IDoSomething(1);

Constraint resolution is realized through template specs...